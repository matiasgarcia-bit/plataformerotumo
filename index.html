<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Redireccionar y Decodificar C贸digo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 50px;
      background-color: #fff5f5;
      color: #6b0000;
    }

    textarea {
      width: 80%;
      height: 150px;
      margin-bottom: 20px;
      font-family: monospace;
      border: 1px solid #cc0000;
      background-color: #fff0f0;
      color: #6b0000;
      padding: 10px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #cc0000;
      color: white;
      border: none;
      border-radius: 4px;
      margin: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #a30000;
    }

    table {
      width: 80%;
      margin-top: 20px;
      border-collapse: collapse;
      background-color: #ffe5e5;
      color: #6b0000;
    }

    th, td {
      padding: 10px;
      border: 1px solid #cc0000;
      text-align: left;
    }

    th {
      background-color: #ffcccc;
    }

    pre {
      text-align: left;
      background-color: #ffe5e5;
      padding: 20px;
      width: 80%;
      margin-top: 20px;
      color: #6b0000;
    }

    .feedback-container {
      background-color: #ffe5e5;
      border: 2px solid #cc0000;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
      color: #6b0000;
    }

    .feedback-message h3 {
      margin-top: 0;
    }

    .copy-button {
      margin-top: 10px;
      background-color: #cc0000;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 3px;
      cursor: pointer;
    }

    .copy-button:hover {
      background-color: #a30000;
    }

    h1, h2, h3 {
      color: #990000;
    }

    hr {
      border: 0;
      border-top: 2px solid #cc0000;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1>Redireccionador y Decodificador de C贸digos</h1>
  <p>Pega aqu铆 tu c贸digo y se abrir谩 la p谩gina correspondiente en una pesta帽a nueva. Tambi茅n se decodificar谩 y mostrar谩 los bloques en varias tablas.</p>
  <textarea id="codeInput" placeholder="Pega aqu铆 tu c贸digo..."></textarea><br>
  <button id="decodeButton">Redirigir y Decodificar</button>
  <button id="decodeOnly">Decodificar</button>
  <button id="redirectOnly">Redirigir</button>

  <div id="blocksTableContainer" style="display: none;">
    <h2>Tablas Generadas</h2>

    <!-- Primera Tabla: Verificaci贸n de Tipos de Bloques -->
    <h3>1. Verificaci贸n de Tipos de Bloques</h3>
    <table id="typesCheckTable">
      <thead>
        <tr>
          <th>Bloque</th>
          <th>Est谩 presente</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>

    <!-- Segunda Tabla: Conteo de Bloques -->
    <h3>2. Conteo de Bloques</h3>
    <table id="blockCountTable">
      <thead>
        <tr>
          <th>Tipo de Bloque</th>
          <th>Cantidad</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>

    <!-- Tercera Tabla: JSON Crudo -->
    <h3>3. JSON Crudo</h3>
    <table id="rawJsonTable">
      <thead>
        <tr>
          <th>Clave</th>
          <th>Valor</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </div>

  <script>
    // Asegurarse de que todo el DOM est谩 cargado antes de asignar la funci贸n al bot贸n
    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('decodeButton').onclick = redirectAndDecode;
      document.getElementById('decodeOnly').onclick = decodeOnly;
      document.getElementById('redirectOnly').onclick = redirectOnly;
    });

    function generateFeedback(jsonData) {
      // Contamos la cantidad de bloques (blocks + coins)
      const blockCounts = {
        'Vertical': 0,
        'Horizontal': 0,
        'Stone': 0,
        'Death': 0,
        'Sand': 0,
        'Coins': jsonData.coins.length || 0,
        'Cup': jsonData.Cup.length || 0
      };

      jsonData.blocks.forEach(block => {
        if (blockCounts.hasOwnProperty(block.type)) {
          blockCounts[block.type]++;
        }
      });

      // C谩lculo de la cantidad total de bloques (solo blocks y coins)
      const totalBlocks = blockCounts['Vertical'] + blockCounts['Horizontal'] + blockCounts['Stone'] + blockCounts['Death'] + blockCounts['Sand'] + blockCounts['Coins'];

      // Verificaci贸n de la presencia de bloques clave (sand, stone, death, y horizontal/vertical)
      const requiredBlocksPresent = ['Stone', 'Death', 'Sand'].every(type => blockCounts[type] > 0) && 
                                    (blockCounts['Vertical'] > 0 || blockCounts['Horizontal'] > 0) && 
                                    jsonData.hasOwnProperty('coins');

      // Generamos el mensaje de retroalimentaci贸n en funci贸n de las condiciones
      let feedbackMessage = '';

      if (totalBlocks >= 10 && requiredBlocksPresent) {
        feedbackMessage = "Buen trabajo, me gust贸 mucho la progresi贸n de la dificultad. 隆Felicitaciones!";
      } else if (totalBlocks >= 10 && !requiredBlocksPresent) {
        feedbackMessage = "Buen trabajo, intenta para la pr贸xima variar un poco m谩s en la selecci贸n de bloques.";
      } else if (totalBlocks < 10 && requiredBlocksPresent) {
        feedbackMessage = "Buen trabajo, intenta para la pr贸xima extender la duraci贸n del nivel.";
      } else {
        feedbackMessage = "Buen trabajo, intenta para la pr贸xima variar un poco la selecci贸n de bloques, adem谩s de extender la duraci贸n del nivel.";
      }

      // Mostrar el mensaje de retroalimentaci贸n con el bot贸n para copiar al portapapeles
      const feedbackContainer = document.createElement('div');
      feedbackContainer.classList.add('feedback-container');
      
      // Contenedor del mensaje de retroalimentaci贸n
      const messageElement = document.createElement('div');
      messageElement.classList.add('feedback-message');
      messageElement.innerHTML = `<h3>Retroalimentaci贸n:</h3><p>${feedbackMessage}</p>`;
      
      // Bot贸n de copiar
      const copyButton = document.createElement('button');
      copyButton.classList.add('copy-button');
      copyButton.textContent = 'Copiar al portapapeles';

      // Funci贸n para copiar el feedback al portapapeles
      copyButton.onclick = function() {
        navigator.clipboard.writeText(feedbackMessage)
          .then(() => alert('隆Retroalimentaci贸n copiada al portapapeles!'))
          .catch(err => alert('No se pudo copiar al portapapeles: ' + err));
      };

      feedbackContainer.appendChild(messageElement);
      feedbackContainer.appendChild(copyButton);
      document.body.prepend(feedbackContainer);
    }

function redirectAndDecode() {
  const code = document.getElementById('codeInput').value.trim();
  if (!code) {
    alert('Por favor pega un c贸digo v谩lido.');
    return;
  }

  // 1. Decodificar Base64
  const decodedBase64 = atob(code);

  // 2. Decodificar URL
  const decodedUrl = decodeURIComponent(decodedBase64);

  // 3. Parsear el JSON
  let jsonData;
  try {
    jsonData = JSON.parse(decodedUrl);
  } catch (e) {
    alert('El c贸digo no es un JSON v谩lido.');
    return;
  }

  // 4. Redirigir a la URL
  const baseUrl = 'https://tumo-product.github.io/PlatformGames/es_AR.html?data=';
  const fullUrl = baseUrl + encodeURIComponent(code);
  window.open(fullUrl, '_blank'); // Abre en pesta帽a nueva

  // 5. Mostrar las tablas solo despu茅s de procesar correctamente el JSON
  document.getElementById('blocksTableContainer').style.display = 'block';
  
  // 6. Generar retroalimentaci贸n
  generateFeedback(jsonData);
  
  showTypesCheckTable(jsonData);
  showBlockCountTable(jsonData);
  showRawJsonTable(jsonData);

  
}
function decodeOnly() {
  const code = document.getElementById('codeInput').value.trim();
  if (!code) {
    alert('Por favor pega un c贸digo v谩lido.');
    return;
  }

  // 1. Decodificar Base64
  const decodedBase64 = atob(code);

  // 2. Decodificar URL
  const decodedUrl = decodeURIComponent(decodedBase64);

  // 3. Parsear el JSON
  let jsonData;
  try {
    jsonData = JSON.parse(decodedUrl);
  } catch (e) {
    alert('El c贸digo no es un JSON v谩lido.');
    return;
  }

  

  // 5. Mostrar las tablas solo despu茅s de procesar correctamente el JSON
  document.getElementById('blocksTableContainer').style.display = 'block';
  
  // 6. Generar retroalimentaci贸n
  generateFeedback(jsonData);
  
  showTypesCheckTable(jsonData);
  showBlockCountTable(jsonData);
  showRawJsonTable(jsonData);
}
    function redirectOnly() {
  const code = document.getElementById('codeInput').value.trim();
  if (!code) {
    alert('Por favor pega un c贸digo v谩lido.');
    return;
  }


  // 4. Redirigir a la URL
  const baseUrl = 'https://tumo-product.github.io/PlatformGames/es_AR.html?data=';
  const fullUrl = baseUrl + encodeURIComponent(code);
  window.open(fullUrl, '_blank'); // Abre en pesta帽a nueva
}

    function showTypesCheckTable(jsonData) {
      const requiredTypes = ['Vertical', 'Horizontal', 'Stone', 'Death', 'Sand'];
      const typesPresence = {};

      // Inicializar todos los tipos como false
      requiredTypes.forEach(type => {
        typesPresence[type] = false;
      });

      // Comprobar si cada tipo de bloque est谩 presente en jsonData.blocks
      jsonData.blocks.forEach(block => {
        if (requiredTypes.includes(block.type)) {
          typesPresence[block.type] = true;
        }
      });

      // Verificar si Cup y Coins est谩n presentes
      const hasCup = jsonData.hasOwnProperty('Cup');
      const hasCoins = jsonData.hasOwnProperty('coins');
      
      const allBlocksPresent = requiredTypes.every(type => typesPresence[type]) && hasCup && hasCoins;

      // Cambiar el emoji dependiendo de si todo est谩 presente
      const statusEmoji = allBlocksPresent ? '' : '';

      const tableBody = document.querySelector('#typesCheckTable tbody');
      tableBody.innerHTML = ''; // Limpiar la tabla antes de llenarla

      // Mostrar todos los tipos de bloques y su estado
      requiredTypes.forEach(type => {
        const row = document.createElement('tr');
        const typeCell = document.createElement('td');
        typeCell.textContent = type;
        row.appendChild(typeCell);

        const statusCell = document.createElement('td');
        statusCell.textContent = typesPresence[type] ? '' : '';
        row.appendChild(statusCell);

        tableBody.appendChild(row);
      });

      // Agregar Cup y Coins a la tabla
      const cupRow = document.createElement('tr');
      cupRow.innerHTML = `<td>Cup</td><td>${hasCup ? '' : ''}</td>`;
      tableBody.appendChild(cupRow);

      const coinsRow = document.createElement('tr');
      coinsRow.innerHTML = `<td>Coins</td><td>${hasCoins ? '' : ''}</td>`;
      tableBody.appendChild(coinsRow);

      // Agregar estado general
      const statusRow = document.createElement('tr');
      statusRow.innerHTML = `<td><strong>Todo Presente</strong></td><td>${statusEmoji}</td>`;
      tableBody.appendChild(statusRow);
    }

    function showBlockCountTable(jsonData) {
      const blockCounts = {
        'Vertical': 0,
        'Horizontal': 0,
        'Stone': 0,
        'Death': 0,
        'Sand': 0,
        'Coins': jsonData.coins.length || 0,
        'Cup': jsonData.cup.length || 0
      };

      // Contar la cantidad de bloques de cada tipo
      jsonData.blocks.forEach(block => {
        if (blockCounts.hasOwnProperty(block.type)) {
          blockCounts[block.type]++;
        }
      });

      const tableBody = document.querySelector('#blockCountTable tbody');
      tableBody.innerHTML = ''; // Limpiar la tabla antes de llenarla

      let totalNormalBlocks = 0;

      for (const type in blockCounts) {
        if (blockCounts.hasOwnProperty(type)) {
          const row = document.createElement('tr');
          const typeCell = document.createElement('td');
          typeCell.textContent = type;
          row.appendChild(typeCell);

          const countCell = document.createElement('td');
          countCell.textContent = blockCounts[type];
          row.appendChild(countCell);

          tableBody.appendChild(row);

          // Sumar los totales
          if (type !== 'Coins' && type !== 'Cup') {
            totalNormalBlocks += blockCounts[type];
          }
        }
      }

      // Agregar las filas de totales
      const totalRow = document.createElement('tr');
      totalRow.innerHTML = `<td><strong>Total Bloques (sin COINS y CUP)</strong></td><td>${totalNormalBlocks}</td>`;
      tableBody.appendChild(totalRow);

      const coinsRow = document.createElement('tr');
      coinsRow.innerHTML = `<td><strong>Total de COINS</strong></td><td>${blockCounts['Coins']}</td>`;
      tableBody.appendChild(coinsRow);

      const cupRow = document.createElement('tr');
      cupRow.innerHTML = `<td><strong>Total de CUP</strong></td><td>${blockCounts['Cup']}</td>`;
      tableBody.appendChild(cupRow);

      const finalTotalRow = document.createElement('tr');
      finalTotalRow.innerHTML = `<td><strong>Total (normal + COINS + CUP)</strong></td><td>${totalNormalBlocks + blockCounts['Coins'] + blockCounts['Cup']}</td>`;
      tableBody.appendChild(finalTotalRow);
    }

    function showRawJsonTable(jsonData) {
  const container = document.getElementById('rawJsonTable');
  container.innerHTML = ''; // Limpiar el contenedor de las tablas

  // Secciones del JSON que queremos mostrar
  const sections = ['blocks', 'camera', 'player', 'coins', 'cup'];

  // Recorrer las secciones
  sections.forEach(section => {
    if (jsonData.hasOwnProperty(section)) {
      // Crear una tabla general para cada secci贸n
      const sectionTable = document.createElement('table');
      sectionTable.innerHTML = `
        <thead>
          <tr>
            <th>Clave</th>
            <th>Valor</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tableBody = sectionTable.querySelector('tbody');
      const sectionData = jsonData[section];

      // T铆tulo para la tabla de la secci贸n
      const sectionTitle = document.createElement('h3');
      sectionTitle.textContent = `Detalles de la secci贸n: ${section.charAt(0).toUpperCase() + section.slice(1)}`;
      container.appendChild(sectionTitle);

      // Si es la secci贸n de "blocks", crear subtablas para cada atributo (x, y, type, editRange)
      if (section === 'blocks') {
        const subTable = document.createElement('table');
        subTable.innerHTML = `
          <thead>
            <tr>
              <th>X</th>
              <th>Y</th>
              <th>Type</th>
              <th>EditRange</th>
            </tr>
          </thead>
          <tbody></tbody>
        `;
        const subTableBody = subTable.querySelector('tbody');

        // Recorrer los bloques y mostrar valores separados por atributos
        sectionData.forEach(block => {
          const row = document.createElement('tr');

          const xCell = document.createElement('td');
          xCell.textContent = block.x;
          row.appendChild(xCell);

          const yCell = document.createElement('td');
          yCell.textContent = block.y;
          row.appendChild(yCell);

          const typeCell = document.createElement('td');
          typeCell.textContent = block.type;
          row.appendChild(typeCell);

          const editRangeCell = document.createElement('td');
          editRangeCell.textContent = block.editRange || 'N/A'; // Si no tiene valor, mostramos N/A
          row.appendChild(editRangeCell);

          subTableBody.appendChild(row);
        });

        container.appendChild(subTable);
      } else {
        // Para las dem谩s secciones (camera, player, coins, cup), mostrar claves y valores
        for (const key in sectionData) {
          if (sectionData.hasOwnProperty(key)) {
            const row = document.createElement('tr');

            const keyCell = document.createElement('td');
            keyCell.textContent = key;
            row.appendChild(keyCell);

            const valueCell = document.createElement('td');
            valueCell.textContent = typeof sectionData[key] === 'object' 
              ? JSON.stringify(sectionData[key], null, 2) 
              : sectionData[key];
            row.appendChild(valueCell);

            tableBody.appendChild(row);
          }
        }
        container.appendChild(sectionTable);
      }

      container.appendChild(document.createElement('hr')); // Separador entre tablas
    }
  });
}

  </script>
</body>
</html>
